//
//  Resea Interface Definitions.
//
//  Every server provides at least one services which definied as "interface",
//  a set of messages that implementors must accept and respond.
//
//  This file defines the interfaces in our own domain specific language. We
//  haven't yet documented the language specification, but it should be pretty
//  straightforward to understand. We use this definition to generate IPC stubs
//  (`resea::idl` module in the Resea userland library in Rust).
//
//  Message Types
//  -------------
//  call     - Send a request & Reply a response (client to server)
//  upcall   - Send a request & Reply a response (server to client)
//  sendonly - Send a request (client to server)
//  event    - Send a data (server to client)
//
//  TODO: upcall is not yet supported.
//
[id(1)]
interface notification {
    [id(1), type(call)]
    notification() -> ()
}

[id(2)]
interface runtime {
    [id(1), type(call)]
    exit(code: int32) -> ()
    [id(2), type(call)]
    printchar(ch: char) -> ()
    [id(3), type(call)]
    print_str(str: string) -> ()
}

[id(3)]
interface server {
    [id(1), type(call)]
    connect(interface: uint8) -> (interface: uint8, ch: channel)
}

[id(4)]
interface pager {
    [id(1), type(call)]
    fill(proc: handle, addr: uintptr, num_pages: size) -> (page: page)
}

[id(5)]
interface timer {
    [id(1), type(call)]
    create(ch: channel, initial: int32, interval: int32) -> (timer: handle)
    [id(2), type(call)]
    reset(timer: handle, initial: int32, interval: int32) -> ()
    [id(3), type(call)]
    clear(timer: handle) -> ()
}

[id(10)]
interface kernel {
    [id(1), type(call)]
    create_process(name: string) -> (proc: handle, pager_ch: channel)
    [id(2), type(call)]
    destroy_process(proc: handle) -> ()
    [id(3), type(call)]
    add_vm_area(proc: handle, start: uintptr, size: size, flags: uint8) -> ()
    [id(4), type(call)]
    inject_channel(proc: handle, ch: channel) -> ()

    [id(5), type(call)]
    spawn_thread(proc: handle, start: uintptr, stack: uintptr, buffer: uintptr,
          arg: uintptr) -> (thread: handle)
    [id(6), type(call)]
    destroy_thread(thread: handle) -> ()

    [id(7), type(call)]
    listen_irq(ch: channel, irq: uint8) -> ()
    [id(8), type(call)]
    read_ioport(addr: uint64, size: size) -> (data: uint64)
    [id(9), type(call)]
    write_ioport(addr: uint64, size: size, data: uint64) -> ()

    [id(10), type(call)]
    get_screen_buffer() -> (page: page)
}

[id(11)]
interface memmgr {
    [id(1), type(call)]
    alloc_pages(num_pages: size) -> (page: page)
    [id(2), type(call)]
    alloc_phy_pages(num_pages: size) -> (paddr: paddr, page: page)
    [id(3), type(call)]
    map_phy_pages(paddr: paddr, num_pages: size) -> (page: page)
}

[id(12)]
interface discovery {
    [id(1), type(call)]
    connect(interface: uint8) -> (ch: channel)
    [id(2), type(call)]
    publish(interface: uint8, ch: channel) -> ()
}

[id(13)]
interface fs {
    [id(1), type(call)]
    open(path: string) -> (file: handle)
    [id(2), type(call)]
    close(handle: handle) -> ()
    [id(3), type(call)]
    read(file: handle, offset: size, len: size) -> (page: page)
    [id(4), type(call)]
    write(file: handle, page: page, len: size) -> ()
}

[id(30)]
interface storage_device {
    [id(1), type(call)]
    read(sector: uintptr, num_sectors: size) -> (page: page)
}

[id(31)]
interface network_device {
    [id(1), type(call)]
    listen(ch: channel) -> ()
    [id(2), type(call)]
    transmit(packet: page, len: size) -> ()

    [id(3), type(event)]
    received(packet: page, len: size) -> ()
}

[id(32)]
interface text_screen_device {
    [id(1), type(call)]
    print_str(str: string) -> ()
    [id(2), type(call)]
    print_char(ch: char) -> ()
}

[id(33)]
interface keyboard_device {
    [id(1), type(call)]
    listen(ch: channel) -> ()

    [id(2), type(event)]
    pressed(ch: char) -> ()
}
