//
//  Resea Interface Definitions.
//
//  Every server provides at least one service which definied as ``interface'',
//  a set of messages that implementors must accept and respond.
//
//  This file defines the interfaces in our own domain specific language. We
//  haven't yet documented the language specification, but it should be pretty
//  straightforward to understand. We use this definition to generate IPC stubs
//  (``resea::idl'' module in the Resea userland library).
//
//  Message Types
//  -------------
//  call   - Request and response messages (sort of Remote Procedure Call).
//  oneway - A one-way message.
//

[id(1)]
interface notification {
    [id(1), type(call)]
    notification() -> ()
}

[id(2)]
interface runtime {
    [id(1), type(call)]
    exit(code: int32) -> ()
    [id(2), type(call)]
    printchar(ch: char) -> ()
    [id(3), type(call)]
    print_str(str: string) -> ()
}

[id(3)]
interface server {
    [id(1), type(call)]
    connect(interface: uint8) -> (interface: uint8, ch: channel)
}

[id(4)]
interface pager {
    [id(1), type(call)]
    fill(proc: handle, addr: uintptr, num_pages: size) -> (page: page)
}

[id(5)]
interface timer {
    [id(1), type(call)]
    create(ch: channel, initial: int32, interval: int32) -> (timer: handle)
    [id(2), type(call)]
    reset(timer: handle, initial: int32, interval: int32) -> ()
    [id(3), type(call)]
    clear(timer: handle) -> ()
    [id(4), type(call)]
    uptime() -> (uptime: uint64)
}

[id(10)]
interface kernel {
    [id(1), type(call)]
    create_process(name: string) -> (proc: handle, pager_ch: channel)
    [id(2), type(call)]
    destroy_process(proc: handle) -> ()
    [id(3), type(call)]
    add_vm_area(proc: handle, start: uintptr, size: size, flags: uint8) -> ()
    [id(4), type(call)]
    inject_channel(proc: handle, ch: channel) -> ()

    [id(5), type(call)]
    spawn_thread(proc: handle, start: uintptr, stack: uintptr, buffer: uintptr,
          arg: uintptr) -> (thread: handle)
    [id(6), type(call)]
    destroy_thread(thread: handle) -> ()

    [id(7), type(call)]
    listen_irq(ch: channel, irq: uint8) -> ()
    [id(8), type(call)]
    read_ioport(addr: uint64, size: size) -> (data: uint64)
    [id(9), type(call)]
    write_ioport(addr: uint64, size: size, data: uint64) -> ()
    [id(10), type(call)]
    batch_write_ioport(
        addr1: uint64, size1: size, data1: uint64,
        addr2: uint64, size2: size, data2: uint64,
        addr3: uint64, size3: size, data3: uint64,
        addr4: uint64, size4: size, data4: uint64
    ) -> ()

    [id(11), type(call)]
    get_screen_buffer() -> (page: page)
    [id(12), type(call)]
    read_kernel_log() -> (str: string)
    [id(13), type(call)]
    read_stats() -> (
        uptime: uint64,
        ipc_total: size,
        page_fault_total: size,
        context_switch_total: size,
        kernel_call_total: size
    )
}

[id(11)]
interface memmgr {
    [id(1), type(call)]
    alloc_pages(num_pages: size) -> (page: page)
    [id(2), type(call)]
    alloc_phy_pages(num_pages: size) -> (paddr: paddr, page: page)
    [id(3), type(call)]
    map_phy_pages(paddr: paddr, num_pages: size) -> (page: page)
}

[id(12)]
interface discovery {
    [id(1), type(call)]
    connect(interface: uint8) -> (ch: channel)
    [id(2), type(call)]
    publish(interface: uint8, ch: channel) -> ()
}

[id(13)]
interface fs {
    [id(1), type(call)]
    open(path: string) -> (file: handle)
    [id(2), type(call)]
    close(handle: handle) -> ()
    [id(3), type(call)]
    read(file: handle, offset: size, len: size) -> (page: page)
    [id(4), type(call)]
    write(file: handle, page: page, len: size) -> ()
}

[id(14)]
interface net {
    [id(1), type(call)]
    tcp_close(sock: handle) -> ()
    [id(2), type(call)]
    tcp_listen(ch: channel, port: uint16) -> (sock: handle)
    [id(3), type(call)]
    tcp_write(sock: handle, data: page) -> ()
}

[id(15)]
interface net_client {
    [id(1), type(oneway)]
    tcp_received(client_sock: handle, data: page) -> ()
    [id(2), type(oneway)]
    tcp_accepted(listen_sock: handle, client_sock: handle) -> ()
}

[id(16)]
interface benchmark {
    [id(1), type(call)]
    nop() -> ()
}


[id(30)]
interface storage_device {
    [id(1), type(call)]
    read(sector: uintptr, num_sectors: size) -> (page: page)
}

[id(31)]
interface network_device {
    [id(1), type(call)]
    get_macaddr() -> (
        addr0: uint8, addr1: uint8, addr2: uint8,
        addr3: uint8, addr4: uint8, addr5: uint8
    )
    [id(2), type(call)]
    listen(ch: channel) -> ()
    [id(3), type(call)]
    transmit(packet: page) -> ()
}

[id(32)]
interface network_device_client {
    [id(1), type(oneway)]
    received(packet: page) -> ()
}

[id(33)]
interface text_screen_device {
    [id(1), type(call)]
    print_str(str: string) -> ()
    [id(2), type(call)]
    print_char(ch: char) -> ()
    [id(3), type(call)]
    clear() -> ()
}

[id(34)]
interface keyboard_device {
    [id(1), type(call)]
    listen(ch: channel) -> ()
}

[id(35)]
interface keyboard_device_client {
    [id(1), type(oneway)]
    pressed(ch: char) -> ()
}
