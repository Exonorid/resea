#!/usr/bin/env python3
import argparse
from pathlib import Path
import jinja2
import json
import re
import os

MACROS = """\
{% macro define_message(interface, msg, reply) %}
{% set fields = msg.rets if reply else msg.args %}
#define {{ interface.name | upper }}_{{ msg.name | upper }}{{ "_REPLY" if reply }}_MSG_INLINE_LEN ({{ fields | inline_len }})
#define {{ interface.name | upper }}_{{ msg.name | upper }}{{ "_REPLY" if reply }}_MSG \
    (((({{ interface.name | upper }}_INTERFACE << 8) {{ "| MSG_REPLY_FLAG" if reply }} | {{ msg.attrs.id }}) << MSG_TYPE_OFFSET) \
{%- if fields.page -%}
    | MSG_PAGE_PAYLOAD \
{%- endif -%}
{%- if fields.channel -%}
    | MSG_CHANNEL_PAYLOAD \
{%- endif -%}
    | (({{ interface.name | upper }}_{{ msg.name | upper }}{{ "_REPLY" if reply }}_MSG_INLINE_LEN) \
        << MSG_INLINE_LEN_OFFSET) \
    )

struct {{ interface.name }}_{{ msg.name }}{{ "_reply" if reply }}_payload {
{%- if fields.channel %}
    cid_t {{ fields.channel.name }};
{%- else %}
    cid_t __unused_channel;
{%- endif %}
{%- if fields.page %}
    vaddr_t {{ fields.page.name }};
    size_t num_pages;
{%- else %}
    vaddr_t __unused_page_addr;
    size_t __unused_num_pages;
{%- endif %}
{%- for field in fields.inlines %}
    {{ field.type | resolve_type }} {{ field.name }};
{%- endfor %}
} PACKED;
{% endmacro %}
"""

TEMPLATE = MACROS + """
//
//  DO NOT MODIFY: IDL stubs generated by kgenstub.py.
//

//
//  Message definitions.
//
{% for interface in interfaces %}
#define {{ interface.name | upper }}_INTERFACE {{ interface.attrs.id }}
    {% for msg in interface.messages %}
        {{ define_message(interface, msg, False) }}
        {%- if msg.attrs.type == "call" %}
            {{ define_message(interface, msg, True) }}
        {%- endif %}
    {%- endfor %}
{%- endfor %}

//  An union for struct message.
#define IDL_MESSAGE_PAYLOADS \
    union { \\
{% for interface in interfaces %} \
        union { \\
    {% for msg in interface.messages %}\
            struct {{ interface.name }}_{{ msg.name }}_payload {{ msg.name }}; \\
    {% if msg.attrs.type == "call" %}\
            struct {{ interface.name }}_{{ msg.name }}_reply_payload {{ msg.name }}_reply; \\
    {% endif %}\
    {% endfor %}\
        } {{ interface.name }}; \\
{% endfor %}\
    };
"""

BUILTIN_TYPES = {
    "int8":     { "name": "int8_t",    "size": "sizeof(int8_t)" },
    "int16":    { "name": "int16_t",   "size": "sizeof(int16_t)" },
    "int32":    { "name": "int32_t",   "size": "sizeof(int32_t)" },
    "int64":    { "name": "int64_t",   "size": "sizeof(int64_t)" },
    "uint8":    { "name": "uint8_t",   "size": "sizeof(uint8_t)" },
    "uint16":   { "name": "uint16_t",  "size": "sizeof(uint16_t)" },
    "uint32":   { "name": "uint32_t",  "size": "sizeof(uint32_t)" },
    "uint64":   { "name": "uint64_t",  "size": "sizeof(uint64_t)" },
    "bool":     { "name": "bool",      "size": "sizeof(bool)" },
    "char":     { "name": "char",      "size": "sizeof(char)" },
    "handle":   { "name": "handle_t",  "size": "sizeof(handle_t)" },
    "channel":  { "name": None,        "size": "0" },
    "page":     { "name": None,        "size": "0" },
    "intmax":   { "name": "intmax_t",  "size": "sizeof(intmax_t)" },
    "uintmax":  { "name": "uintmax_t", "size": "sizeof(uintmax_t)" },
    "uintptr":  { "name": "vaddr_t",   "size": "sizeof(vaddr_t)" },
    "paddr":    { "name": "paddr_t",   "size": "sizeof(paddr_t)" },
    "size":     { "name": "size_t",    "size": "sizeof(size_t)" },
    "string":   { "name": "string_t",  "size": "sizeof(string_t)" },
}

def resolve_type(type_name):
    assert type_name in BUILTIN_TYPES
    return BUILTIN_TYPES[type_name]["name"]

def inline_len(params):
    sizes = []
    for field in params["inlines"]:
        typename = field["type"]
        sizes.append(BUILTIN_TYPES[typename]["size"])
    if len(sizes) == 0:
        return "0"
    else:
        return " + ".join(sizes)

def genstub(idl):
    renderer = jinja2.Environment()
    renderer.filters["resolve_type"] = resolve_type
    renderer.filters["inline_len"] = inline_len
    return renderer.from_string(TEMPLATE).render(interfaces= idl)

def main():
    parser = argparse.ArgumentParser(description="The IDL C stub generator for kernel.")
    parser.add_argument("idl_json", help="The parsed IDL JSON file.")
    parser.add_argument("out_file", help="The output file.")
    args = parser.parse_args()

    idl = json.load(open(args.idl_json))
    stub = genstub(idl)
    with open(args.out_file, "w") as f:
        f.write(stub)

if __name__ == "__main__":
    main()
