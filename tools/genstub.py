#!/usr/bin/env python3
import argparse
from pathlib import Path
import jinja2
import json
import re
import os

TEMPLATE = """\
//
//  DO NOT MODIFY: Message definitions for {{ name }} interface generated by genstub.py.
//
use crate::message::*;
use crate::error::Error;
use crate::arch::syscall;
use crate::channel::{CId, Channel};
use crate::std::string::String;

pub const INTERFACE_ID: u8 = {{ attrs.id }};

{% for msg in messages %}
pub const {{ msg.name | upper }}_MSG_INLINE_LEN: usize = ({{ msg.args | inline_len }});
pub const {{ msg.name | upper }}_MSG: MessageHeader =
    MessageHeader::new( \
        (((INTERFACE_ID as u32) << 8) | {{ msg.attrs.id }}) << MSG_TYPE_OFFSET \
{%- if msg.args.page -%}
        | MSG_PAGE_PAYLOAD  \
{%- endif -%}
{%- if msg.args.channel -%}
        | MSG_CHANNEL_PAYLOAD  \
{%- endif -%}
        | (({{ msg.name | upper }}_MSG_INLINE_LEN as u32) << MSG_INLINE_LEN_OFFSET) \
    );

#[repr(C, packed)]
pub struct {{ msg.name | camelcase }}Msg {
    pub header: MessageHeader,
    pub from: CId,
    pub notification: Notification,
{%- if msg.args.channel %}
    pub {{ msg.args.channel.name }}: CId,
{%- else %}
    __unused_channel: CId,
{%- endif %}
{%- if msg.args.page %}
    pub {{ msg.args.page.name }}: Page,
{%- else %}
    __unused_page: Page,
{%- endif %}
{%- for field in msg.args.inlines %}
    pub {{ field.name }}: {{ field.type | resolve_type_in_msg_struct }},
{%- endfor %}
}

{%- if msg.attrs.type == "call" %}
pub const {{ msg.name | upper }}_REPLY_MSG_INLINE_LEN: usize = ({{ msg.rets | inline_len }});
pub const {{ msg.name | upper }}_REPLY_MSG: MessageHeader =
    MessageHeader::new( \
        ((((INTERFACE_ID as u32) << 8) | MSG_REPLY_FLAG | {{ msg.attrs.id }}) << MSG_TYPE_OFFSET) \
{%- if msg.rets.page -%}
        | MSG_PAGE_PAYLOAD  \
{%- endif -%}
{%- if msg.rets.channel -%}
        | MSG_CHANNEL_PAYLOAD  \
{%- endif -%}
        | (({{ msg.name | upper }}_REPLY_MSG_INLINE_LEN as u32) << MSG_INLINE_LEN_OFFSET) \
    );

#[repr(C, packed)]
pub struct {{ msg.name | camelcase }}ReplyMsg {
    pub header: MessageHeader,
    pub from: CId,
    pub notification: Notification,
{%- if msg.rets.channel %}
    pub {{ msg.rets.channel.name }}: CId,
{%- else %}
    __unused_channel: CId,
{%- endif %}
{%- if msg.rets.page %}
    pub {{ msg.rets.page.name }}: Page,
{%- else %}
    __unused_page: Page,
{%- endif %}
{%- for field in msg.rets.inlines %}
    pub {{ field.name }}: {{ field.type | resolve_type_in_msg_struct }},
{%- endfor %}
    __unused_data: [u8; INLINE_PAYLOAD_LEN_MAX - {{ msg.name | upper }}_REPLY_MSG_INLINE_LEN]
}
{%- endif %}

{%- endfor %}

{% for msg in messages %}
pub fn send_{{ msg.name }}({{ msg.args | arg_params("__ch: &Channel") }}) -> Result<(), Error> {
    Err(Error::Unimplemented)
}
{% endfor -%}

pub trait Client {
    fn client_channel(&self) -> &Channel;
{% for msg in messages %}
{%- if msg.attrs.type == "call" %}
    fn {{ msg.name }}({{ msg.args | arg_params("&self") }}) -> Result<{{ msg.rets | ret_params }}, Error> {
        let __ch = self.client_channel();
        let mut __m: Message =
            unsafe { core::mem::MaybeUninit::uninit().assume_init() };
        let mut __m2 =
            unsafe { core::mem::transmute::<&mut Message, &mut {{ msg.name | camelcase }}Msg>(&mut __m) };
        __m2.header = {{ msg.name | upper }}_MSG;
{%- if msg.args.channel %}
        __m2.{{ msg.args.channel.name }} = {{ msg.args.channel.name }}.cid();
{%- endif %}
{%- for field in msg.args.inlines %}
        __m2.{{ field.name }} = {{ field | to_payload }};
{%- endfor %}
        __ch.call(&__m).map(|__r| {
            let __r = unsafe { core::mem::transmute::<Message, {{ msg.name | camelcase }}ReplyMsg>(__r) };
{%- if msg.rets.fields | length == 1 %}
            let {{ msg.rets.fields[0].name }} = __r.{{ msg.rets.fields[0].name }};
            {{ msg.rets.fields[0] | from_payload }}
{%- else %}
{%- for field in msg.rets.fields -%}
            let {{ field.name }} = __r.{{ field.name }};
{%- endfor -%}
            (
{%- for field in msg.rets.fields -%}
            {{ field | from_payload }},
{%- endfor -%}
            )
{%- endif %}
        })
    }
{%- endif %}
{% endfor -%}
}

impl Client for Channel {
    // FIXME: Remove this method.
    fn client_channel(&self) -> &Channel { self }
}

pub trait Server {
{%- for msg in messages %}
{%- if msg.attrs.type == "call" %}
    fn {{ msg.name }}({{ msg.args | arg_params("&mut self") }}) -> Option<Result<{{ msg.rets | ret_params }}, Error>>;
{%- endif %}
{%- endfor %}
    fn __handle(&mut self, m: &mut Message) -> bool {
        match m.header {
{%- for msg in messages %}
            {{ msg.name | upper }}_MSG => {
                let req = unsafe { core::mem::transmute::<&mut Message, &mut {{ msg.name | camelcase }}Msg>(m) };
                match self.{{ msg.name }}({{ msg.args | call_args("req") }}) {
                    Some(Ok(rets)) => {
                        let resp = unsafe { core::mem::transmute::<&mut Message, &mut {{ msg.name | camelcase }}ReplyMsg>(m) };
                        resp.header = {{ msg.name | upper }}_REPLY_MSG;
                    {%- if msg.rets.fields | length == 1 %}
                        let {{ msg.rets.fields[0].name }} = rets;
                        resp.{{ msg.rets.fields[0].name }} = {{ msg.rets.fields[0] | to_payload }};
                    {%- else %}
                    {%- for field in msg.rets.fields %}
                        let {{ field.name }} = rets.{{ loop.index0 }};
                        resp.{{ field.name }} = {{ field | to_payload }};
                    {%- endfor %}
                    {%- endif %}
                        true
                    }
                    Some(Err(err)) => {
                        m.header = MessageHeader::from_error(err);
                        true
                    }
                    None => {
                        false
                    }
                }
            }
{%- endfor %}
            _ => {
                m.header = MessageHeader::from_error(Error::UnknownMessage);
                true
            },
        }
    }
}
"""

builtin_types = {
    "int8":     { "name_in_msg": None, "name": "i8",       "size": "core::mem::size_of::<i8>()" },
    "int16":    { "name_in_msg": None, "name": "i16",      "size": "core::mem::size_of::<i16>()" },
    "int32":    { "name_in_msg": None, "name": "i32",      "size": "core::mem::size_of::<i32>()" },
    "int64":    { "name_in_msg": None, "name": "i64",      "size": "core::mem::size_of::<i64>()" },
    "uint8":    { "name_in_msg": None, "name": "u8",       "size": "core::mem::size_of::<u8>()" },
    "uint16":   { "name_in_msg": None, "name": "u16",      "size": "core::mem::size_of::<u16>()" },
    "uint32":   { "name_in_msg": None, "name": "u32",      "size": "core::mem::size_of::<u32>()" },
    "uint64":   { "name_in_msg": None, "name": "u64",      "size": "core::mem::size_of::<u64>()" },
    "bool":     { "name_in_msg": None, "name": "bool",     "size": "core::mem::size_of::<bool>()" },
    "char":     { "name_in_msg": None, "name": "u8",       "size": "core::mem::size_of::<u8>()" },
    "cid":      { "name_in_msg": None, "name": "CId",      "size": "core::mem::size_of::<CId>()" },
    "handle":   { "name_in_msg": None, "name": "HandleId", "size": "core::mem::size_of::<HandleId>()" },
    "channel":  { "name_in_msg": None, "name": "Channel",  "size": "0" },
    "page":     { "name_in_msg": None, "name": "Page",     "size": "0" },
    "intmax":   { "name_in_msg": None, "name": "isize",    "size": "core::mem::size_of::<isize>()" },
    "uintmax":  { "name_in_msg": None, "name": "usize",    "size": "core::mem::size_of::<usize>()" },
    "uintptr":  { "name_in_msg": None, "name": "usize",    "size": "core::mem::size_of::<usize>()" },
    "paddr":    { "name_in_msg": None, "name": "usize",    "size": "core::mem::size_of::<usize>()" },
    "size":     { "name_in_msg": None, "name": "usize",    "size": "core::mem::size_of::<usize>()" },
    "string":   { "name_in_msg": "FixedString", "name": "String", "size": "core::mem::size_of::<FixedString>()" },
}

# Resolves a type name to a corresponding builtin type.
def resolve_type(type_name):
    assert type_name in builtin_types
    return builtin_types[type_name]["name"]

def resolve_type_in_msg_struct(type_name):
    assert type_name in builtin_types
    if builtin_types[type_name]["name_in_msg"] is not None:
        return builtin_types[type_name]["name_in_msg"]
    else:
        return builtin_types[type_name]["name"]

def inline_len(params):
    sizes = []
    for field in params["inlines"]:
        typename = field["type"]
        sizes.append(builtin_types[typename]["size"])
    if len(sizes) == 0:
        return "0"
    else:
        return " + ".join(sizes)

def call_args(args, msg_var):
    values = []
    for arg in args["fields"]:
        value = f"{msg_var}.{arg['name']}"
        if arg["type"] == "channel":
            values.append(f"Channel::from_cid({value})")
        elif arg["type"] == "handle":
            values.append(f"{value}")
        elif arg["type"] in ["string"]:
            values.append(f"{value}.to_string()")
        else:
            values.append(f"{value}")
    return ", ".join(values)

def arg_params(args, first_param):
    params = [first_param]
    for arg in args["fields"]:
        if arg["type"] in ["handle", "channel"]:
            params.append(f"{arg['name']}: {resolve_type(arg['type'])}")
        else:
            params.append(f"{arg['name']}: {resolve_type(arg['type'])}")
    return ", ".join(params)

def ret_params(rets):
    params = []
    for ret in rets["fields"]:
        params.append(resolve_type(ret['type']))
    if len(params) == 1:
        return params[0]
    else:
        return "(" + ", ".join(params) + ")"

def from_payload(field):
    if field["type"] == "string":
        return f"{field['name']}.to_string()"
    elif field["type"] == "channel":
        return f"Channel::from_cid({field['name']})"
    else:
        return f"{field['name']}"

def to_payload(field):
    if field["type"] == "string":
        return f"FixedString::from_str({field['name']}.as_str())"
    elif field["type"] == "channel":
        return f"{field['name']}.cid()"
    else:
        return f"{field['name']}"

def genstub(out_dir, idl):
    renderer = jinja2.Environment()
    renderer.filters["camelcase"] \
        = lambda x: "".join(map(lambda frag: frag.title(), x.split("_")))
    renderer.filters["resolve_type"] = resolve_type
    renderer.filters["resolve_type_in_msg_struct"] = resolve_type_in_msg_struct
    renderer.filters["inline_len"] = inline_len
    renderer.filters["arg_params"] = arg_params
    renderer.filters["ret_params"] = ret_params
    renderer.filters["call_args"] = call_args
    renderer.filters["to_payload"] = to_payload
    renderer.filters["from_payload"] = from_payload

    os.makedirs(out_dir, exist_ok=True)
    with open(Path(out_dir) / "README.md", "w") as f:
        f.write("# IDL stubs files generated by genstub.py")

    with open(Path(out_dir) / "mod.rs", "w") as mod:
        for interface in idl:
            stub = renderer.from_string(TEMPLATE).render(**interface)
            with open(Path(out_dir) / (interface["name"] + ".rs"), "w") as f:
                f.write(stub)

            mod.write(f"pub mod {interface['name']};\n")

def main():
    parser = argparse.ArgumentParser(description="The IDL stub generator.")
    parser.add_argument("idl_json", help="The parsed IDL JSON file.")
    parser.add_argument("out_dir", help="The output diretory.")
    args = parser.parse_args()

    idl = json.load(open(args.idl_json))
    genstub(args.out_dir, idl)

if __name__ == "__main__":
    main()
